Codex Instructions (Codex 5.3)
==============================

Status (2026-02-12)
------------------
Current state:
- Streaming is ring-delta (newly-visible chunks enqueue only when mesh is missing).
- Dirty rebuild scheduling is amortized/lazy (no O(queue) rebucket spikes under backlog).
- Rebuild is ms-budgeted.
- HUD diagnostics exist for:
  - streaming enqueue count (`Stream: Enqueued N`)
  - dirty intake vs queued (`DirtyIn` / `Queued`)
  - rebuild ms spent vs budget (`Rebuild: <ms> / <budget> ms`)

On desktop hardware it now plays smoothly and typically averages ~90-100 FPS.

Remaining potential spike from the audit:
- `ChunkRenderer:_pruneChunkMeshes()` is O(meshCache) and is called on priority chunk changes.
  - Even if it is not currently noticeable, this is the last obvious one-frame O(n) maintenance path tied to chunk crossings.

Update (2026-02-12)
------------------
Implemented:
- Incremental mesh-cache pruning with per-frame caps (removes O(meshCache) crossing spikes).
- Prune diagnostics in HUD (`Prune: scanned ... removed ... pending ...`).
- New config knobs in `Constants.REBUILD`:
  - `pruneMaxChecksPerFrame`
  - `pruneMaxMillisPerFrame`

Goal ("Clear Done Line")
-----------------------
Remove any one-frame O(meshCache) maintenance work on chunk crossings while preserving:
- Stable, bounded mesh cache size while traveling.
- Existing renderer + streaming architecture (no major rewrite).
- Pointer lock/input behavior unchanged.

Non-Goals
---------
- Infinite world
- New worldgen systems/biomes/caves
- Multiplayer
- Input/control changes
- Major renderer redesign

Key Constraints
---------------
- Do not regress pointer lock:
  - Click captures mouse.
  - Tab toggles lock.
  - Esc unlocks first, then existing menu behavior.
- Keep hot loops allocation-light:
  - Avoid creating new tables/strings per-frame in prune/rebuild loops.

Implementation Tasks (Do Together)
----------------------------------

1) Amortize Mesh Cache Pruning (Incremental Pass)
-------------------------------------------------
Files: src/render/ChunkRenderer.lua, src/constants.lua

Problem
- `ChunkRenderer:setPriorityOriginWorld` currently calls `_pruneChunkMeshes()` directly.
- `_pruneChunkMeshes()` scans the entire mesh cache table with `pairs(...)` and can hitch on chunk crossings when the cache is large.

Fix
Convert pruning into an incremental pass spread across frames using a safe cursor.

A) Add prune state to ChunkRenderer
- `self._prunePending` (bool)
- `self._pruneCursorKey` (table key or nil)
- `self._pruneKeepRadius` (int)

Optional per-frame diagnostics (for HUD verification):
- `self._pruneScannedLastFrame` (int)
- `self._pruneRemovedLastFrame` (int)

B) On priority chunk change, schedule pruning (do not prune immediately)
In `ChunkRenderer:setPriorityOriginWorld(...)`:
- Update priority chunk coords as usual.
- Do NOT scan `_chunkMeshes` in this function.
- Compute and cache `keepRadius = drawRadius + alwaysVisiblePadding + meshCachePadding` (same logic as current prune).
- Set:
  - `self._prunePending = true`
  - `self._pruneCursorKey = nil` (restart pass)
  - `self._pruneKeepRadius = keepRadius`

C) Add a bounded prune step that runs each frame
Add `ChunkRenderer:_pruneChunkMeshesStep(maxChecks, maxMillis)`:
- If `_prunePending` is false, return quickly.
- Iterate incrementally using `next(self._chunkMeshes, cursorKey)`.
- Keep iteration safe while deleting:
  - For each `key, entry`, compute `afterKey, afterEntry = next(self._chunkMeshes, key)` BEFORE any deletion.
  - Decide whether to delete `self._chunkMeshes[key] = nil` based on distance.
  - Advance using `key, entry = afterKey, afterEntry` so you never call `next` with a removed key.
  - Track a `lastKeptKey` so the saved cursor is always a key that still exists (or nil).
- Stop when:
  - scanned >= `maxChecks`, OR
  - time >= `maxMillis` (if timer is available), OR
  - end-of-table (then clear `_prunePending` and reset cursor).

D) Where to call the prune step
Run the prune step once per frame.
Recommended: call it inside `ChunkRenderer:rebuildDirty(...)` (it already runs in the update loop).
Pruning should have its own small budget so it does not steal rebuild budget unpredictably.

E) No extra allocations
- Do not allocate a `remove = {}` list each prune step.
- Prefer cached `entry.cx/entry.cz` (entries built by `_rebuildChunk` should already have these).
  - If missing, `parseKey(key)` once and cache back onto `entry` so it becomes a one-time cost.

F) Add config knobs (defaults)
In `src/constants.lua`, add under `Constants.REBUILD`:
- `pruneMaxChecksPerFrame = 128`
- `pruneMaxMillisPerFrame = 0.25`
These defaults are intentionally small: eliminate spikes, not finish pruning instantly.

2) Optional: HUD Prune Diagnostics (Verification)
-------------------------------------------------
Files: src/render/ChunkRenderer.lua, src/game/GameState.lua, src/ui/HUD.lua

Goal
Make it easy to confirm pruning is incremental and bounded.

Implementation
- Track `pruneScanned` and `pruneRemoved` each frame on the renderer (plus whether prune is pending).
- Expose them to the HUD alongside existing renderer stats.
- Add a perf HUD line (only when perf HUD is on), e.g.:
  - `Prune: scanned <n>  removed <m>  pending <yes/no>`

Manual Test Checklist
---------------------
1) Stand still:
- `Dirty` reaches 0 and stays stable.
- `Prune` should go idle (pending false) quickly.

2) Walk in a single direction for 2+ minutes:
- No chunk-crossing hitch spikes from pruning.
- Mesh cache remains bounded (no unbounded growth).

3) Stress:
- Increase `Constants.CULL.drawRadiusChunks` and `Constants.CULL.meshCachePaddingChunks`.
- Ensure crossing remains smooth and prune stats show bounded per-frame work.

4) Visual correctness:
- No near-field chunks disappear unexpectedly.
- Only far cached meshes get pruned.

5) Input/menu/save:
- Pointer lock + menu behavior unchanged.
- Save/load unaffected.

Acceptance Criteria
-------------------
- `ChunkRenderer:setPriorityOriginWorld` performs no full mesh-cache scan on chunk crossings.
- Pruning work is amortized and bounded per frame (checks/ms caps), eliminating O(meshCache) spikes.
- Mesh cache still converges to the keep radius while traveling (bounded memory).
- Optional: HUD verifies prune work and pending state.
