Codex Instructions (Codex 5.3)
==============================

Status (2026-02-09)
------------------
- The "Rebuild Scheduling + Perf HUD" task below has been implemented.
- The perf HUD was simplified to focused runtime metrics (FPS + frame time + chunk/rebuild/dirty counts).

Task (Next): Reduce Dirty-Key Per-Frame Allocations
--------------------------------------------------
`ChunkWorld:getDirtyChunkKeys()` currently allocates a new table every frame (even when there are no
dirty chunks), and this runs every frame via `ChunkRenderer:rebuildDirty(...)`.

Goal: avoid per-frame allocations in the common idle case (no dirty chunks), while preserving correctness
when chunks are dirty (edits/generation).

Goals
-----
- Zero allocations per frame when no dirty chunks exist.
- Minimal allocations when dirty chunks exist (amortized / reuse scratch buffers).
- Preserve behavior: dirty chunks are not dropped; all dirty chunks eventually rebuild.
- Keep implementation simple and low-risk.

Constraints
-----------
- Performance-first; keep per-frame allocations low.
- World marks dirty chunks; renderer consumes and schedules rebuild work.
- Do not regress pointer lock / input behavior.

Scope
-----
Primary:
- `src/world/ChunkWorld.lua`: implement a low-alloc "drain dirty keys" API.
- `src/render/ChunkRenderer.lua`: use a reusable scratch buffer and avoid allocating tables per frame.

Recommended Implementation (API + Behavior)
------------------------------------------
Add a new method on `ChunkWorld` that drains dirty keys into a caller-provided array, returning a count.
This avoids allocating a new list each frame and supports an early-out when there are no dirty keys.

Suggested API:
- `function ChunkWorld:drainDirtyChunkKeys(out)`
  - Inputs:
    - `out`: array table to fill with dirty chunk key strings.
  - Returns:
    - `count`: number of keys written to `out[1..count]`.

Required behavior:
1) Early out without allocating:
   - If `next(self._dirty) == nil`, return `0` and leave `self._dirty` unchanged.
2) When dirty exists:
   - Fill `out` densely from index 1..count.
   - Clear any leftover entries in `out` from previous calls (`out[count+1] = nil` ...).
   - Reset `self._dirty` to an empty table (or clear it) so keys are not returned twice.

Renderer integration:
- In `ChunkRenderer.new`, add `self._dirtyScratch = {}`.
- In `ChunkRenderer:rebuildDirty(...)`:
  - Call `local count = self.world:drainDirtyChunkKeys(self._dirtyScratch)`.
  - If `count > 0`, queue dirty keys using `count` (avoid `#out` on reused tables).
  - Update `_queueDirtyKeys` to accept `(dirtyKeys, count)` and iterate `for i = 1, count do ... end`.

Alternate (Minimal) Implementation (If You Want Fewer Touch Points)
------------------------------------------------------------------
If you want to avoid changing the renderer call site, you can keep `getDirtyChunkKeys()` but add an early-out:
- If `next(self._dirty) == nil`, return a shared constant empty array and do not replace `self._dirty`.
This removes the per-frame allocation when idle, but still allocates during dirty frames.

Manual Test Checklist
--------------------
- Idle:
  - Stand still without edits; dirty queue should remain 0 and no rebuilds should occur.
- Edits:
  - Break/place blocks rapidly; dirty queue should increase and then drain as rebuilds happen.
  - No missing rebuilds: after edits stop, dirty queue eventually returns to 0.
- Regression:
  - Confirm rebuild prioritization still prefers nearby chunks and stays within the per-frame budget.

Definition of Done
------------------
- No per-frame dirty-key list allocations when there are no dirty chunks.
- Dirty chunk rebuild behavior is unchanged: no dropped/stuck rebuilds.
- Code remains simple and easy to reason about.

Task: Rebuild Scheduling + Perf HUD (FPS + Pass Stats)
-----------------------------------------------------
Implement prioritized dirty-chunk rebuild scheduling so edits near the player rebuild first, and
add a small performance HUD that displays FPS plus `pass:getStats()` data (and optional timing
fields when enabled).

Goals
-----
- Reduce "edit lag": when breaking/placing blocks, nearby chunks rebuild before far chunks.
- Keep rebuild work bounded per frame (no spikes).
- Add on-screen perf visibility:
  - FPS (device-visible debug).
  - Visible chunk count + rebuilds-per-frame.
  - `pass:getStats()` values (draws/computes/drawsCulled, CPU memory, and optional submit/gpu time when timing is enabled).

Constraints
-----------
- Performance-first; keep per-frame allocations low.
- Do not regress pointer lock / input behavior.
- Chunks are marked dirty by the world; renderer must consume and schedule rebuilds.
- Keep files ASCII when practical; update `DEVLOG.md` and `README.md` if new controls are added.

Scope
-----
Primary:
- `src/render/ChunkRenderer.lua`:
  - Replace FIFO dirty scheduling with prioritized scheduling (near player first).
- `src/game/GameState.lua`:
  - Provide the renderer a per-frame priority origin (camera position).
- `src/ui/HUD.lua`:
  - Display FPS + pass stats + existing chunk debug counters.

Optional (recommended):
- `src/constants.lua`:
  - Add knobs for rebuild budget and priority behavior.
- `src/input/Input.lua`:
  - Add a toggle key (suggest `F3`) for showing/hiding the perf overlay.

Implementation plan
-------------------
1) Add config knobs (constants).
   - Add a table like:
     - `Constants.REBUILD = { maxPerFrame = 3, prioritize = true, prioritizeHorizontalOnly = true }`
     - `Constants.PERF = { showHud = true, showPassStats = true, enableTiming = false }`
   - Keep defaults conservative (no extra overhead unless requested).

2) Add a priority origin API to the renderer.
   - In `ChunkRenderer`, add something like:
     - `setPriorityOriginWorld(cameraX, cameraY, cameraZ)`
   - Convert world coords to chunk coords without allocating:
     - `pcx = floor(cameraX / chunkSize) + 1` (same for y/z).
   - Store last-known priority chunk coords on the renderer.

3) Implement prioritized dirty scheduling.
   - Current: dirty keys are queued FIFO; rebuild picks first N.
   - New: rebuild should prefer dirty chunks closest to the player's current chunk.
   - Recommended approach (low-alloc, scalable):
     - Use distance buckets keyed by chunk-space distance from the priority chunk.
     - `dist = max(abs(cx - pcx), abs(cz - pcz))` (ignore y if horizontal priority is enabled).
     - Enqueue dirty keys into `buckets[dist]` with head/tail indices per bucket.
     - Rebuild loop scans buckets from `dist=0` upward until budget exhausted.
     - Keep `_dirtyQueued` dedupe so chunks aren't enqueued multiple times.
   - Re-prioritize when player moves:
     - When the priority chunk changes, re-bucket existing queued keys once (O(n) in queued size).
     - This keeps "nearest-first" accurate without sorting every frame.

4) Wire the priority origin from game loop.
   - In `GameState:update`, after player movement and before `renderer:rebuildDirty(...)`:
     - Compute camera position (`player:getCameraPosition()`).
     - Call `renderer:setPriorityOriginWorld(cameraX, cameraY, cameraZ)`.
   - Keep rebuild budget per frame configurable via constants.

5) Add perf HUD (FPS + pass stats).
   - FPS:
     - Use `lovr.timer.getFPS()` and display it in the HUD.
   - Pass stats:
     - In `GameState:draw(pass)`, call `local stats = pass:getStats()` and pass it to HUD state.
     - In `HUD:draw`, format a compact line:
       - `draws`, `computes`, `drawsCulled`, `cpuMemoryUsed`, `cpuMemoryReserved` (guard if fields are missing).
       - If timing is enabled and fields exist, show `submitTime`/`gpuTime` (note: docs mention a few frames of delay).
   - Optional timing enable:
     - If `Constants.PERF.enableTiming` is true, call `lovr.graphics.setTimingEnabled(true)` once
       during load (guard if function is missing).
   - Optional (nice-to-have):
     - Also show `lovr.graphics.getStats()` VRAM info (`bufferMemory`, `textureMemory`, `memoryBudget`, `memoryUsage`), if desired.

6) Add a runtime toggle (optional but recommended).
   - Bind `F3` to toggle perf HUD visibility.
   - Update `README.md` controls if a toggle is added.

Manual test checklist
---------------------
- Edit lag:
  - Break/place blocks and confirm the chunk you touched rebuilds within 1-2 frames, even if other
    chunks are dirty.
  - Dirty a far chunk (e.g. edit something, walk away) and confirm near edits still rebuild first.
- Stability:
  - No dropped rebuilds: leave multiple chunks dirty and wait; all should eventually rebuild.
- Perf HUD:
  - FPS displays and updates.
  - `pass:getStats()` line displays without errors; missing fields do not crash (show "n/a").
  - If timing enabled, verify timing fields appear and look reasonable.

Definition of done
------------------
- Nearby dirty chunks rebuild first consistently (no obvious "wrong chunk rebuilt first" delays).
- Rebuild work remains bounded per frame (no large frame spikes from rebuild scheduling).
- HUD shows FPS and pass stats reliably; overlay can be toggled if implemented.
- `DEVLOG.md` updated, and `README.md` updated if any new controls were added.
