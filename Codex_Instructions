Codex Instructions (Codex 5.3)
==============================

Task: Reduce Frame-Time Spikes (Render Radius 16)
------------------------------------------------

Date: 2026-02-20

Context
-------
At render radius 16, average FPS is high (~250), but frame-time spikes occur:
- Idle / looking around: spikes to 20ms+
- Moving / streaming chunks: spikes to 60ms+

Goal
----
Reduce spikes (micro-stutter) by removing obvious per-frame allocations and avoidable
O(n log n) work, without changing gameplay or visuals.

Hard Constraints (Do Not Break)
------------------------------
- No gameplay, input, menu, or save-format changes.
- No world-gen changes.
- No lighting correctness changes (only performance refactors).
- Keep pointer lock / bag / pause flows intact.
- Keep files ASCII when practical.
- Minimal diffs; avoid broad refactors.
- Update DEVLOG.md with a short perf entry. Do not change README.md.

Acceptance Criteria
-------------------
- Lower "Worst(1s)" spikes at idle and while turning the camera in place.
- Fewer large spikes while moving and streaming.
- No visible change to alpha rendering order compared to current behavior.
- The touched hot paths no longer allocate new tables/functions every frame.

Implementation Plan (Do In This Order)
--------------------------------------

1) Alpha: Remove Per-Frame table.sort in Draw
Files: src/render/ChunkRenderer.lua

Problem:
- ChunkRenderer:draw currently sorts visible alpha chunks every frame:
  - table.sort(alphaScratch, alphaSortBackToFront)
- Alpha sort key is entry._sortDistSq (distance squared to camera), which depends on
  camera position, not look direction.

Solution:
- Maintain a persistent alpha draw order list sorted by camera POSITION.
- Rebuild/sort only when camera position changes or when alpha meshes are created/removed.
- Avoid double culling: compute visibility once per frame, then draw alpha by filtering
  the cached alpha list.

Steps:
A) Add renderer fields in ChunkRenderer.new:
- self._drawFrameId = 0
- self._alphaOrder = {}
- self._alphaOrderCount = 0
- self._alphaOrderDirty = true
- self._alphaOrderCamX/Y/Z = nil

B) Mark cached alpha list dirty when alpha presence changes:
- In ChunkRenderer:_setChunkMeshEntry:
  - Compare previous entry.alpha (nil/non-nil) vs new alphaMesh (nil/non-nil).
  - If alpha presence changed, set self._alphaOrderDirty = true.
- In any prune/remove path that deletes an entry with alpha, also set dirty.

C) Add a method ChunkRenderer:_ensureAlphaOrder(cameraX, cameraY, cameraZ):
- If not dirty and camera position is unchanged (use epsilon on squared distance), return.
- Otherwise rebuild:
  - Clear self._alphaOrder using self._alphaOrderCount (no new tables).
  - Iterate pairs(self._chunkMeshes) and collect entries where entry.alpha exists.
  - Compute entry._sortDistSq = (entry.centerX - cameraX)^2 + (entry.centerY - cameraY)^2 + (entry.centerZ - cameraZ)^2
  - Sort self._alphaOrder back-to-front using existing alphaSortBackToFront.
  - Store cameraX/Y/Z to self._alphaOrderCam*, set dirty false, update count.

D) Refactor ChunkRenderer:draw:
- At function start: self._drawFrameId = (self._drawFrameId or 0) + 1
- In the existing pairs(self._chunkMeshes) visibility loop:
  - Compute visibility once with _isVisibleChunk(...).
  - If visible: set entry._visibleFrame = self._drawFrameId.
  - Keep current opaqueScratch build/draw behavior (including optional opaque sort).
  - Do NOT build/sort alphaScratch anymore.
- Before alpha pass:
  - Call self:_ensureAlphaOrder(cameraX, cameraY, cameraZ).
- Alpha draw pass:
  - Iterate i=1..self._alphaOrderCount in order.
  - For each entry: if entry.alpha exists and entry._visibleFrame == self._drawFrameId then pass:draw(...).
- Remove the old per-frame alphaScratch + table.sort(alphaScratch, ...) path.

Notes:
- Keep the existing alpha sort key (distance squared) to preserve current visual behavior.
- Rebuild must happen when camera moves OR alpha meshes appear/disappear.

2) Floodfill Lighting: Remove Per-Op Closure Allocation
Files: src/world/lighting/FloodfillLighting.lua

Problem:
- _propagateSkyDarkFrom and _propagateSkyFloodFrom define a local tryNeighbor closure
  on every call, then call it 6 times.

Solution:
- Inline/unroll the 6 neighbor checks with straight-line code (no nested function).
- Cache common locals (world, sizeX/sizeY/sizeZ) at top of the function.

Steps:
- In FloodfillLighting:_propagateSkyDarkFrom (around where local function tryNeighbor exists):
  - Remove the local function.
  - Inline the neighbor checks for:
    (x-1,y,z), (x+1,y,z), (x,y-1,z), (x,y+1,z), (x,y,z-1), (x,y,z+1)
  - Keep logic identical (bounds, propagation bounds, enqueue dark/flood).
  - Keep the final self:_enqueueSkyFlood(worldIndex, urgent) behavior.
- In FloodfillLighting:_propagateSkyFloodFrom: do the same unroll.

3) Renderer: Eliminate Per-Frame Tables/Closures In Rebuild Paths
Files: src/render/ChunkRenderer.lua

Problem:
- ChunkRenderer:rebuildDirty allocates per call:
  - deferredEntries = {}
  - local functions deferEntry and processRebuildEntry
- ChunkRenderer:_applyThreadedResults allocates per call:
  - local function processResult

Solution:
- Reuse a persistent deferred list table owned by the renderer.
- Inline helper bodies or move them to methods so no per-call closures are created.

Steps:
A) In ChunkRenderer.new add:
- self._deferredEntries = {}
- self._deferredCount = 0

B) In ChunkRenderer:rebuildDirty:
- Replace local deferredEntries = {} with local deferredEntries = self._deferredEntries.
- Track deferredCount as a number and clear tail using the previous count.
- Remove local function deferEntry and inline its 2-line body at call sites.
- Remove local function processRebuildEntry and inline its logic inside the while loop.

C) In ChunkRenderer:_applyThreadedResults:
- Remove local function processResult(result).
- Inline the logic where results are popped, OR move to a method like:
  - ChunkRenderer:_processThreadedResult(result)
  defined once at file scope.

Acceptance check:
- After this change, rebuildDirty and _applyThreadedResults should not allocate new
  tables/functions every frame.

4) World Dirty Drain: Reuse self._dirty Table (No Table Swap)
Files: src/world/ChunkWorld.lua

Problem:
- ChunkWorld:drainDirtyChunkKeys ends by assigning self._dirty = {} (per-call table alloc).

Solution:
- Clear the existing table while draining.

Steps:
- In ChunkWorld:drainDirtyChunkKeys(out):
  - When self._dirty is non-empty:
    - for key in pairs(self._dirty) do
      - count = count + 1; out[count] = key
      - self._dirty[key] = nil
    - end
  - Preserve trimming of out tail to nil as it is today.
  - Do not assign a new table to self._dirty.

Manual Verification
-------------------
Run: lovr .

With CULL.drawRadiusChunks = 16, use F3 perf HUD and compare before/after:
- Idle (not moving, not turning)
- Turning in place (rotate only)
- Moving across chunk boundaries (streaming)

Look at:
- Perf: Frame ms and Worst(1s)
- Rebuild: ... ms
- LightQ: Pending/Tasks

Documentation
-------------
Add a DEVLOG.md entry dated 2026-02-20 summarizing:
- alpha draw sorting cache
- floodfill propagation unroll (no closures)
- renderer rebuild path allocation removals
- dirty drain table reuse
